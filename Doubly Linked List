Doubly Linked List:
======================
A Doubly Linked List (DLL) is a linear data structure where each node contains links to both the next and previous node.
Unlike a singly linked list (which moves only forward), a doubly linked list allows traversal in both directions.

Node Structure:
===================
Structure based Node:
struct Node {
    int data;
    Node* next;
    Node* prev;
};

Class based Node:
class Node {
public:
    int data;
    Node* next;
    Node* prev;

    //constructor
    Node(int data) {
        this -> data = data;
        this -> next = NULL;
        this -> prev = NULL;
    }
};

Example Representation
text
NULL ← A ⇄ B ⇄ C ⇄ D → NULL

A.prev = NULL
A.next = B


B.prev = A
B.next = C


C.prev = B
C.next = D


D.prev = C
D.next = NULL




Characteristics / Features:

Each node has 2 pointers (prev and next).


Can be traversed in both forward and backward direction.


Insertion / Deletion is easier (if pointer to the node is given).


Requires extra memory (for prev pointer).


Used in browser history, playlist, undo/redo operations etc.



Example:

NULL ← A ⇄ B ⇄ C ⇄ D → NULL


Doubly Linked List Class Definition:
=======================================
class DoublyLinkedList {

private:
    Node* head;
    Node* tail;
    int size;

public:
    DoublyLinkedList() {
        head = NULL;
        tail = NULL;
        size = 0;
    }

    //all operations go here
};


Traversing a Doubly Linked List:

Forward Traversal – using next pointer from head to tail


Backward Traversal – using prev pointer from tail to head


void displayForward() {
    Node* temp = head;
    while(temp != NULL){
        cout << temp->data << " ⇄ ";
        temp = temp->next;
    }
    cout<<"NULL"<<endl;
}

void displayBackward(){
    Node* temp = tail;
    while(temp != NULL){
        cout<< temp->data <<" ⇄ ";
        temp = temp->prev;
    }
    cout<<"NULL"<<endl;
}


Insert at Beginning:

Logic:
Create new node


Connect it with existing head


Update head (and tail if list was empty)


void insertAtBeginning(int value){
    Node* newNode = new Node(value);

    if(head == NULL){
        head = tail = newNode;
    } else {
        newNode->next = head;
        head->prev = newNode;
        head = newNode;
    }
    size++;
}

Example:
Insert 5 into 10 ⇄ 20 ⇄ 30
→ 5 ⇄ 10 ⇄ 20 ⇄ 30


Insert at End:

void insertAtEnd(int value){
    Node* newNode = new Node(value);

    if(head == NULL){
        head = tail = newNode;
    } else {
        tail->next = newNode;
        newNode->prev = tail;
        tail = newNode;
    }
    size++;
}

Example:
10 ⇄ 20 ⇄ 30   insert 40
→ 10 ⇄ 20 ⇄ 30 ⇄ 40


Insert at Any Position:

If index = 0 → insertAtBeginning


If index = size → insertAtEnd


Else → insert in middle


void insertAt(int index, int value){
    if(index < 0 || index > size){
        cout<<"Invalid Index\n";
        return;
    }
    if(index == 0){
        insertAtBeginning(value);
        return;
    }
    if(index == size){
        insertAtEnd(value);
        return;
    }

    Node* newNode = new Node(value);
    Node* current = head;

    for(int i = 0; i < index - 1; i++){
        current = current->next;
    }
    newNode->next = current->next;
    newNode->prev = current;
    current->next->prev = newNode;
    current->next = newNode;

    size++;
}


Deletion Operations



Delete First Node:

void removeFirst(){
    if(head == NULL){
        cout<<"List is empty\n";
        return;
    }
    if(head == tail){
        delete head;
        head = tail = NULL;
    } else {
        Node* temp = head;
        head = head->next;
        head->prev = NULL;
        delete temp;
    }
    size--;
}


Delete Last Node:

void removeLast(){
    if(head == NULL){
        cout<<"List is empty\n";
        return;
    }
    if(head == tail){
        delete head;
        head = tail = NULL;
    } else {
        Node* temp = tail;
        tail = tail->prev;
        tail->next = NULL;
        delete temp;
    }
    size--;
}


Delete at Any Position:

void deleteAt(int index){
    if(index < 0 || index >= size){
        cout<<"Invalid Index\n";
        return;
    }
    if(index == 0){
        removeFirst();
        return;
    }
    if(index == size-1){
        removeLast();
        return;
    }
    Node* current = head;
    for(int i = 0; i < index; i++){
        current = current->next;
    }
    current->prev->next = current->next;
    current->next->prev = current->prev;
    delete current;
    size--;
}





Searching in DLL


int indexOf(int value) {
    Node* current = head;
    int index = 0;
    while (current != NULL) {
        if (current->data == value) return index;
        current = current->next;
        index++;
    }
    return -1;
}



Reversing a Doubly Linked List:

void reverse(){
    Node* current = head;
    Node* temp = NULL;

    // swap next and prev for all nodes
    while(current != NULL){
        temp = current->prev;
        current->prev = current->next;
        current->next = temp;
        current = current->prev;
    }

    // Swap head & tail
    if(temp != NULL){
        head = temp->prev;
    }
}


Time Complexity of Operations in DLL:
========================================
Operation
Time Complexity
Insert at beginning
O(1)
Insert at end
O(1)
Insert at middle
O(n)
Delete at beginning
O(1)
Delete at end
O(1)
Delete at middle
O(n)
Traversal (forward/back)
O(n)
Reverse
O(n)


Real Life Analogy:

Think of doubly linked list like a train with bogies having connectors both in front and back.
You can move forward (using next bogie coupling) and backward (using previous bogie coupling).














 Doubly Linked List – Intermediate & Advanced Problems (with Logic & Examples)
===============================================================================

1. Find Middle of DLL  

  Logic**:
- Use two pointers (`slow`, `fast`).  
- Move `slow` by 1 step, and `fast` by 2 steps.  
- When `fast` reaches the end, `slow` will be at the middle.


Node* findMiddle() {
    if (head == NULL) return NULL;

    Node* slow = head;
    Node* fast = head;

    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow; 
}


**Example**:  
`10 ⇄ 20 ⇄ 30 ⇄ 40 ⇄ 50`  
- `slow` → 10, `fast` → 10  
- Move: `slow` = 20, `fast` = 30  
- Move: `slow` = 30, `fast` = 50  
✅ Middle = **30**



2. Remove Duplicates from Sorted DLL  

**Logic**:
- Traverse DLL from start.  
- If `current->data == current->next->data`, **delete current->next**.  
- Move forward only if no duplicate found.


void removeDuplicates() {
    if (head == NULL) return;
    Node* current = head;

    while (current != NULL && current->next != NULL) {
        if (current->data == current->next->data) {
            Node* temp = current->next;
            current->next = temp->next;
            if (temp->next != NULL) {
                temp->next->prev = current;
            } else {
                tail = current;
            }
            delete temp;
            size--;
        } else {
            current = current->next;
        }
    }
}


**Example**:  
Input → `10 ⇄ 20 ⇄ 20 ⇄ 30 ⇄ 30 ⇄ 40`  
Output → `10 ⇄ 20 ⇄ 30 ⇄ 40`



3. Check if DLL is Palindrome  

**Logic**:
- Use two pointers: `left = head`, `right = tail`.  
- Compare values while moving inwards.  
- If mismatch found → return false.  


bool isPalindrome() {
    if (head == NULL) return true;

    Node* left = head;
    Node* right = tail;

    while (left != NULL && right != NULL && left != right && right->next != left) {
        if (left->data != right->data) return false;
        left = left->next;
        right = right->prev;
    }
    return true;
}


**Example**:  
- `1 ⇄ 2 ⇄ 3 ⇄ 2 ⇄ 1` → ✅ Palindrome  
- `10 ⇄ 20 ⇄ 30` → ❌ Not a palindrome  



4. Rotate DLL by K Nodes  

**Logic**:
- Traverse `k` nodes.  
- Break the list at that position.  
- Make new head = node after `k`.  
- Connect `tail->next` to old head and fix `prev` links.  


void rotate(int k) {
    if (!head || k <= 0) return;

    k = k % size;
    if (k == 0) return;

    Node* current = head;
    for (int i = 1; i < k; i++) {
        current = current->next;
    }
    Node* newHead = current->next;
    newHead->prev = NULL;
    current->next = NULL;

    tail->next = head;
    head->prev = tail;

    head = newHead;
    
    // update new tail
    tail = current;
}


**Example**:  
DLL = `10 ⇄ 20 ⇄ 30 ⇄ 40 ⇄ 50`  
Rotate by 2 → `30 ⇄ 40 ⇄ 50 ⇄ 10 ⇄ 20`



5. Merge Two Sorted DLLs  

**Logic**:
- Use recursion or iteration.  
- Pick smaller node from two lists.  
- Adjust `prev` and `next`.  


Node* mergeSorted(Node* first, Node* second) {
    if (!first) return second;
    if (!second) return first;

    if (first->data < second->data) {
        first->next = mergeSorted(first->next, second);
        if (first->next) first->next->prev = first;
        first->prev = NULL;
        return first;
    } else {
        second->next = mergeSorted(first, second->next);
        if (second->next) second->next->prev = second;
        second->prev = NULL;
        return second;
    }
}


**Example**:  
L1 = `10 ⇄ 30 ⇄ 50`  
L2 = `20 ⇄ 40 ⇄ 60`  
Merged → `10 ⇄ 20 ⇄ 30 ⇄ 40 ⇄ 50 ⇄ 60`


6. Sort a DLL using Merge Sort  

**Logic**:
- Split list into two halves.  
- Recursively sort two halves.  
- Merge the two sorted halves.  


Node* split(Node* head) {
    Node* fast = head;
    Node* slow = head;
    while (fast->next && fast->next->next) {
        fast = fast->next->next;
        slow = slow->next;
    }
    Node* second = slow->next;
    slow->next = NULL;
    return second;
}

Node* mergeSort(Node* node) {
    if (!node || !node->next)
        return node;

    Node* second = split(node);

    node = mergeSort(node);
    second = mergeSort(second);

    return mergeSorted(node, second);
}


**Example**:  
Input = `40 ⇄ 10 ⇄ 30 ⇄ 20`  
Output = `10 ⇄ 20 ⇄ 30 ⇄ 40`



7. Convert DLL to Circular DLL  

**Logic**:
- Set `tail->next = head` and `head->prev = tail`.  

void makeCircular() {
    if (head == NULL) return;
    tail->next = head;
    head->prev = tail;
}


**Example**:  
`10 ⇄ 20 ⇄ 30 → NULL`  
After conversion →  
`10 ⇄ 20 ⇄ 30 ⇄ (back to 10...)`



8. Detect Loop in DLL  

**Logic**:
- Use **Floyd’s cycle detection algorithm** (slow, fast pointers).  
- If they meet → loop exists.  


bool hasLoop() {
    Node* slow = head;
    Node* fast = head;

    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) return true;
    }
    return false;
}


**Example**:  
- If `tail->next` accidentally points to `head` → loop detected.  



✅ Summary  

- Middle** → use slow & fast pointers  
- Remove duplicates** → check adjacent nodes in sorted DLL  
- Palindrome** → compare head & tail  
- Rotate by k** → break after k, reattach  
- Merge sort on DLL** → split + merge  
- Circular DLL** → connect `head` & `tail`  
- Loop detection** → Floyd’s algorithm  
